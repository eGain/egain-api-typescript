/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ReferenceResponse,
  ReferenceResponse$inboundSchema,
  ReferenceResponse$Outbound,
  ReferenceResponse$outboundSchema,
} from "./referenceresponse.js";
import {
  SearchResult,
  SearchResult$inboundSchema,
  SearchResult$Outbound,
  SearchResult$outboundSchema,
} from "./searchresult.js";

/**
 * Indicates whether the answer was extracted directly from documents or generated by the LLM.
 */
export const AnswersResponseAnswerType = {
  Certified: "certified",
  Generative: "generative",
} as const;
/**
 * Indicates whether the answer was extracted directly from documents or generated by the LLM.
 */
export type AnswersResponseAnswerType = ClosedEnum<
  typeof AnswersResponseAnswerType
>;

export type AnswersResponseAnswer = {
  /**
   * The main response text. May be a certified answer or a generative answer produced by the LLM.
   */
  answerValue: string;
  /**
   * Supporting sources that were used to produce the answer.
   */
  references: Array<ReferenceResponse>;
  /**
   * Indicates whether the answer was extracted directly from documents or generated by the LLM.
   */
  answerType: AnswersResponseAnswerType;
  /**
   * Query-specific relevance score (0.0-1.0) indicating how well the result matches the user query. For Certified answers, the score represents a direct relevance comparison between the query and the returned snippet. For Generative answers, the score is assigned by the model after generation, based on how well the response is supported by the provided knowledge.
   *
   * @remarks
   */
  relevanceScore: number;
};

/**
 * The channel where the query originated, e.g., directly from the portal or via a custom integration.
 */
export const AnswersResponseType = {
  Portal: "portal",
  Custom: "custom",
} as const;
/**
 * The channel where the query originated, e.g., directly from the portal or via a custom integration.
 */
export type AnswersResponseType = ClosedEnum<typeof AnswersResponseType>;

export type AnswersResponseChannel = {
  /**
   * The channel where the query originated, e.g., directly from the portal or via a custom integration.
   */
  type: AnswersResponseType;
  /**
   * The channel name.
   */
  name?: string | undefined;
};

export type AnswersResponse = {
  answer: AnswersResponseAnswer;
  /**
   * List of top search results used to support the answer. Includes snippets, metadata, and relevance scores.
   */
  searchResults: Array<SearchResult>;
  channel?: AnswersResponseChannel | undefined;
  /**
   * Unique ID for this specific API call or event.
   */
  eventId?: string | undefined;
  /**
   * Session ID passed by the client for this specific API call or event.
   */
  clientSessionId?: string | undefined;
  /**
   * eGain Session ID that ties multiple API calls to the same user session. Will be used as part of to tie events back to a session.
   */
  sessionId: string;
};

/** @internal */
export const AnswersResponseAnswerType$inboundSchema: z.ZodNativeEnum<
  typeof AnswersResponseAnswerType
> = z.nativeEnum(AnswersResponseAnswerType);

/** @internal */
export const AnswersResponseAnswerType$outboundSchema: z.ZodNativeEnum<
  typeof AnswersResponseAnswerType
> = AnswersResponseAnswerType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnswersResponseAnswerType$ {
  /** @deprecated use `AnswersResponseAnswerType$inboundSchema` instead. */
  export const inboundSchema = AnswersResponseAnswerType$inboundSchema;
  /** @deprecated use `AnswersResponseAnswerType$outboundSchema` instead. */
  export const outboundSchema = AnswersResponseAnswerType$outboundSchema;
}

/** @internal */
export const AnswersResponseAnswer$inboundSchema: z.ZodType<
  AnswersResponseAnswer,
  z.ZodTypeDef,
  unknown
> = z.object({
  answerValue: z.string(),
  references: z.array(ReferenceResponse$inboundSchema),
  answerType: AnswersResponseAnswerType$inboundSchema,
  relevanceScore: z.number(),
});

/** @internal */
export type AnswersResponseAnswer$Outbound = {
  answerValue: string;
  references: Array<ReferenceResponse$Outbound>;
  answerType: string;
  relevanceScore: number;
};

/** @internal */
export const AnswersResponseAnswer$outboundSchema: z.ZodType<
  AnswersResponseAnswer$Outbound,
  z.ZodTypeDef,
  AnswersResponseAnswer
> = z.object({
  answerValue: z.string(),
  references: z.array(ReferenceResponse$outboundSchema),
  answerType: AnswersResponseAnswerType$outboundSchema,
  relevanceScore: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnswersResponseAnswer$ {
  /** @deprecated use `AnswersResponseAnswer$inboundSchema` instead. */
  export const inboundSchema = AnswersResponseAnswer$inboundSchema;
  /** @deprecated use `AnswersResponseAnswer$outboundSchema` instead. */
  export const outboundSchema = AnswersResponseAnswer$outboundSchema;
  /** @deprecated use `AnswersResponseAnswer$Outbound` instead. */
  export type Outbound = AnswersResponseAnswer$Outbound;
}

export function answersResponseAnswerToJSON(
  answersResponseAnswer: AnswersResponseAnswer,
): string {
  return JSON.stringify(
    AnswersResponseAnswer$outboundSchema.parse(answersResponseAnswer),
  );
}

export function answersResponseAnswerFromJSON(
  jsonString: string,
): SafeParseResult<AnswersResponseAnswer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnswersResponseAnswer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnswersResponseAnswer' from JSON`,
  );
}

/** @internal */
export const AnswersResponseType$inboundSchema: z.ZodNativeEnum<
  typeof AnswersResponseType
> = z.nativeEnum(AnswersResponseType);

/** @internal */
export const AnswersResponseType$outboundSchema: z.ZodNativeEnum<
  typeof AnswersResponseType
> = AnswersResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnswersResponseType$ {
  /** @deprecated use `AnswersResponseType$inboundSchema` instead. */
  export const inboundSchema = AnswersResponseType$inboundSchema;
  /** @deprecated use `AnswersResponseType$outboundSchema` instead. */
  export const outboundSchema = AnswersResponseType$outboundSchema;
}

/** @internal */
export const AnswersResponseChannel$inboundSchema: z.ZodType<
  AnswersResponseChannel,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: AnswersResponseType$inboundSchema,
  name: z.string().optional(),
});

/** @internal */
export type AnswersResponseChannel$Outbound = {
  type: string;
  name?: string | undefined;
};

/** @internal */
export const AnswersResponseChannel$outboundSchema: z.ZodType<
  AnswersResponseChannel$Outbound,
  z.ZodTypeDef,
  AnswersResponseChannel
> = z.object({
  type: AnswersResponseType$outboundSchema,
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnswersResponseChannel$ {
  /** @deprecated use `AnswersResponseChannel$inboundSchema` instead. */
  export const inboundSchema = AnswersResponseChannel$inboundSchema;
  /** @deprecated use `AnswersResponseChannel$outboundSchema` instead. */
  export const outboundSchema = AnswersResponseChannel$outboundSchema;
  /** @deprecated use `AnswersResponseChannel$Outbound` instead. */
  export type Outbound = AnswersResponseChannel$Outbound;
}

export function answersResponseChannelToJSON(
  answersResponseChannel: AnswersResponseChannel,
): string {
  return JSON.stringify(
    AnswersResponseChannel$outboundSchema.parse(answersResponseChannel),
  );
}

export function answersResponseChannelFromJSON(
  jsonString: string,
): SafeParseResult<AnswersResponseChannel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnswersResponseChannel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnswersResponseChannel' from JSON`,
  );
}

/** @internal */
export const AnswersResponse$inboundSchema: z.ZodType<
  AnswersResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  answer: z.lazy(() => AnswersResponseAnswer$inboundSchema),
  searchResults: z.array(SearchResult$inboundSchema),
  channel: z.lazy(() => AnswersResponseChannel$inboundSchema).optional(),
  eventId: z.string().optional(),
  clientSessionId: z.string().optional(),
  sessionId: z.string(),
});

/** @internal */
export type AnswersResponse$Outbound = {
  answer: AnswersResponseAnswer$Outbound;
  searchResults: Array<SearchResult$Outbound>;
  channel?: AnswersResponseChannel$Outbound | undefined;
  eventId?: string | undefined;
  clientSessionId?: string | undefined;
  sessionId: string;
};

/** @internal */
export const AnswersResponse$outboundSchema: z.ZodType<
  AnswersResponse$Outbound,
  z.ZodTypeDef,
  AnswersResponse
> = z.object({
  answer: z.lazy(() => AnswersResponseAnswer$outboundSchema),
  searchResults: z.array(SearchResult$outboundSchema),
  channel: z.lazy(() => AnswersResponseChannel$outboundSchema).optional(),
  eventId: z.string().optional(),
  clientSessionId: z.string().optional(),
  sessionId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnswersResponse$ {
  /** @deprecated use `AnswersResponse$inboundSchema` instead. */
  export const inboundSchema = AnswersResponse$inboundSchema;
  /** @deprecated use `AnswersResponse$outboundSchema` instead. */
  export const outboundSchema = AnswersResponse$outboundSchema;
  /** @deprecated use `AnswersResponse$Outbound` instead. */
  export type Outbound = AnswersResponse$Outbound;
}

export function answersResponseToJSON(
  answersResponse: AnswersResponse,
): string {
  return JSON.stringify(AnswersResponse$outboundSchema.parse(answersResponse));
}

export function answersResponseFromJSON(
  jsonString: string,
): SafeParseResult<AnswersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnswersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnswersResponse' from JSON`,
  );
}
