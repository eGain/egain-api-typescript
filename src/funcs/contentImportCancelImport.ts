/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { EgainCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { EgainError } from "../models/errors/egainerror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import { CancelImportServerList } from "../models/operations/cancelimport.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Cancel an import or validation job
 *
 * @remarks
 * # Cancel Import or Validation Job
 *
 * ## Overview
 * This API allows users to cancel import or validation operations that are currently in progress or scheduled for future execution. Cancellation is immediate for scheduled jobs and graceful for running jobs.
 *
 * ## Cancellation Behavior
 * - **Scheduled Jobs**: Immediate cancellation, no processing occurs
 * - **In Progress Jobs**: Graceful shutdown, current item completes, no new items start
 * - **Completed Jobs**: Cannot be cancelled (returns error)
 * - **Failed Jobs**: Cannot be cancelled (already stopped)
 *
 * ## When to Cancel
 * - **Content Issues**: Discover problems with source content
 * - **Timing Changes**: Need to reschedule for different time
 * - **Resource Constraints**: System resources are needed elsewhere
 * - **User Request**: Manual cancellation by authorized users
 * - **System Maintenance**: Planned maintenance windows
 *
 * ## Cancellation Process
 * 1. **Request Received**: System receives cancellation request
 * 2. **Status Check**: Verifies current job status
 * 3. **Graceful Shutdown**: For running jobs, completes current item
 * 4. **Resource Cleanup**: Releases allocated system resources
 * 5. **Status Update**: Marks job as cancelled
 * 6. **Notification**: Updates job status and logs
 *
 * ## Post-Cancellation
 * - **Job Status**: Changes to "Cancelled"
 * - **Partial Results**: Any completed items remain in system
 * - **Logs**: Cancellation reason and timing recorded
 * - **Resources**: System resources freed for other operations
 *
 * ## Best Practices
 * - **Monitor Jobs**: Regularly check job status to identify candidates for cancellation
 * - **Plan Cancellations**: Schedule cancellations during low-usage periods
 * - **Resource Planning**: Consider resource impact before cancelling large jobs
 *
 * ## Permissions
 * | Actor | Permission |
 * | ------- | --------|
 * | User |<li>User must be a department user.</li><li>Content can only be validated for user's home department.</li><li>User must have 'Author' role.</li><li>The job must have been created by the logged in user, or the logged in user must have 'Edit' permissions on the user who created the job.</li></ul>|
 */
export function contentImportCancelImport(
  client: EgainCore,
  request: operations.CancelImportRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    void,
    | errors.WSErrorCommon
    | EgainError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: EgainCore,
  request: operations.CancelImportRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      void,
      | errors.WSErrorCommon
      | EgainError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.CancelImportRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const baseURL = options?.serverURL
    || pathToFunc(CancelImportServerList[0], { charEncoding: "percent" })();

  const pathParams = {
    job_id: encodeSimple("job_id", payload.job_id, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/import/content/{job_id}/cancel")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: baseURL ?? "",
    operationID: "cancelImport",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.accessToken,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: baseURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "403", "404", "406", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    void,
    | errors.WSErrorCommon
    | EgainError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(204, z.void()),
    M.jsonErr([401, 403, 404, 406], errors.WSErrorCommon$inboundSchema),
    M.jsonErr(500, errors.WSErrorCommon$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
