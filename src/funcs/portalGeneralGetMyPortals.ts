/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { EgainCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { EgainError } from "../models/errors/egainerror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Get All Portals Accessible To User
 *
 * @remarks
 * ## Overview
 *   The Get All Portals Accessible to User API allows a user to fetch all portals accessible to user across all department.
 *   * If no access tags are specified for a portal, then any user can access the portal.
 *   * If access tags are specified for a portal, users with a user profile that allows access have access to the portal. For users with multiple user profiles, the user profile that allows access does not need to be the active user profile.
 *   * All the global users(partition) cannot be assigned user profiles; their access is limited to portals without access restrictions.
 *   * The only articles returned are associated to an Article type when the parameter, “Include in browse on portals” is set to "Yes".
 *   * When the "shortUrlTemplate" query parameter is provided, the API filters accessible portals according to the specified language and template name. Portal Short URL specific to to the "shortUrlTemplate" query parameter value is returned in the response.
 *   * When there is no short URL available for a specific language, the API returns a portal object with an empty "shortURL" field.
 */
export function portalGeneralGetMyPortals(
  client: EgainCore,
  request: operations.GetMyPortalsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.AllAccessiblePortals | undefined,
    | errors.WSErrorCommon
    | EgainError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: EgainCore,
  request: operations.GetMyPortalsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.AllAccessiblePortals | undefined,
      | errors.WSErrorCommon
      | EgainError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.GetMyPortalsRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/myportals")();

  const query = encodeFormQuery({
    "$lang": payload.language,
    "$order": payload.order,
    "$pagenum": payload.pagenum,
    "$pagesize": payload.pagesize,
    "$sort": payload.sort,
    "department": payload.department,
    "filterText": payload.filterText,
    "shortUrlTemplate": payload.shortUrlTemplate,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "Accept-Language": encodeSimple(
      "Accept-Language",
      payload["Accept-Language"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getMyPortals",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "406", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.AllAccessiblePortals | undefined,
    | errors.WSErrorCommon
    | EgainError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, models.AllAccessiblePortals$inboundSchema.optional()),
    M.nil(204, models.AllAccessiblePortals$inboundSchema.optional()),
    M.jsonErr([400, 401, 403, 404, 406], errors.WSErrorCommon$inboundSchema),
    M.jsonErr(500, errors.WSErrorCommon$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
