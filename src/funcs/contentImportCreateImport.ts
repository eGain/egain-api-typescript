/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { EgainCore } from "../core.js";
import { encodeJSON } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { EgainError } from "../models/errors/egainerror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import { CreateImportServerList } from "../models/operations/createimport.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Import content from external sources
 *
 * @remarks
 * # Import Content
 *
 * ## Overview
 * This API initiates a bulk content import operation from Amazon S3 buckets. It creates an asynchronous import job that processes content in the background, allowing you to import large volumes of content without blocking your application.
 *
 * ## How It Works
 * 1. **Job Creation**: The API creates an import job and returns a unique job ID
 * 2. **Content Processing**: Content is processed asynchronously in the background
 * 3. **Status Monitoring**: Use the job ID to monitor progress via the Status API
 * 4. **Completion**: Job completes when all content is processed or errors occur
 *
 * ## Supported Operations
 * - **Import**: Add new content to the knowledge base
 * - **Update**: Modify existing content
 *
 * ## Data Source Types
 * - AWS S3 bucket
 * - Shared file path
 *
 * ## Best Practices
 * - **Scheduling**: Use scheduleTime for off-peak imports to minimize system impact
 * - **Monitoring**: Regularly check job status and logs for any issues
 * - **Error Handling**: Review failed items and retry with corrections
 *
 * ## Permissions
 * | Actor | Permission |
 * | ------- | --------|
 * | User |<ul><li>User must be a department user.</li><li>Content can only be imported in user's home department.</li><li>User must have 'Author' role.</li><li>Content can only be imported if the user has all the required languages assigned.</li></ul>|
 */
export function contentImportCreateImport(
  client: EgainCore,
  request: models.ImportContent,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.CreateImportResponse | undefined,
    | errors.WSErrorCommon
    | errors.SchemasWSErrorCommon
    | EgainError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: EgainCore,
  request: models.ImportContent,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.CreateImportResponse | undefined,
      | errors.WSErrorCommon
      | errors.SchemasWSErrorCommon
      | EgainError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => models.ImportContent$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });

  const baseURL = options?.serverURL
    || pathToFunc(CreateImportServerList[0], { charEncoding: "percent" })({
      API_DOMAIN: "api.egain.cloud",
    });

  const path = pathToFunc("/import/content")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: baseURL ?? "",
    operationID: "createImport",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.accessToken,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: baseURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "406", "412", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.CreateImportResponse | undefined,
    | errors.WSErrorCommon
    | errors.SchemasWSErrorCommon
    | EgainError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(202, operations.CreateImportResponse$inboundSchema.optional(), {
      hdrs: true,
    }),
    M.jsonErr([400, 401, 403, 406], errors.WSErrorCommon$inboundSchema),
    M.jsonErr(412, errors.SchemasWSErrorCommon$inboundSchema),
    M.jsonErr(500, errors.WSErrorCommon$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
